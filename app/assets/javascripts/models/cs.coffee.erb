new Mem.Rule("face").schema ->
  @order "order"
  @scope (all)->
    tag: (tag_id)->
      switch tag_id
        when "all"
          all
        else
          all.in(tags:tag_id)

    chr_jobs: (chr_job_id)->
      all.where({chr_job_id})



    name_head: ->
      counts = []
      for idx in ["ア".charCodeAt(0) .. "ン".charCodeAt(0)]
        key = String.fromCharCode idx
        names = all.where(name:///^#{key}///).list().map((o)-> o.name)
        counts[names.length] ?= []
        counts[names.length].push "<#{key}>#{names.join(" ")}"
      counts

  item =
    count: 1
  @map_reduce (o, emit)->
    emit "all", "all", item
    for tag in o.tags
      emit "tag", tag, item



new Mem.Rule("chr_set").schema ->
  @order "caption"

  @default ->
    chr_jobs: ->
      Mem.chr_jobs.where(chr_set_id: @_id)
    chr_npcs: ->
      Mem.chr_npcs.where(chr_set_id: @_id)


new Mem.Rule("chr_npc").schema ->
  @belongs_to "chr_set", dependent: true
  @belongs_to "face", dependent: true

  @deploy (o)->


new Mem.Rule("chr_job").schema ->
  @order (o)-> o.face.order
  @belongs_to "chr_set", dependent: true
  @belongs_to "face", dependent: true
  @deploy (o)->
    o.chr_job_id = o._id
    o.chr_set_idx = order.indexOf o.chr_set_id

  order = [
    "ririnra"
    "wa"
    "time"
    "sf"
    "mad"
    "ger"
    "changed"
    "animal"
    "school"
    "all"
  ]

  @scope (all)->
    face: (face_id)->
      all.where((o)-> face_id == o.face_id).sort(false, (o)-> o.chr_set_idx )


Mem.rule.face.set <%- JSON.stringify(FACE) %>


<%
  for (key in csets) {
    var data = csets[key];

 %>
Mem.rule.chr_set.merge [<%- JSON.stringify(data.chr_set) %>]
Mem.rule.chr_npc.merge <%-  JSON.stringify(data.chr_npc) %>
Mem.rule.chr_job.merge <%-  JSON.stringify(data.chr_job) %>
<% } %>

list =
  for face in Mem.faces.list()
    chr_set_id = "all"
    face_id = face._id
    _id = "all_#{face_id}"
    job = Mem.chr_jobs.face(face_id).list().first?.job
    continue unless job?
    {chr_set_id, face_id, job, _id}

Mem.rule.chr_job.merge list
