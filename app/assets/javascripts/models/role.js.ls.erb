new Mem.Rule("role").schema ->
  id_index = SOW_RECORD.roles.concat SOW_RECORD.gifts

  @order "order"

  @scope (all)->
    is: (side)->
      all.where (o)->
        o.side == side && -1 < o.order

    hide: ->
      all.where (o)->
        o.order < 0

  @default ->

  @deploy (o)->
    o.ables ||= []
    o.HELP ||= ""

    o.order = id_index.indexOf o._id

    o.side = o.group.toLowerCase() if o.group? && o.group != "OTHER"
    o.side = "gift"  if ("gift" in o.ables)
    if o.group == "MOB"
      o.side = "mob"
      o.order = 0
    o.side = "other" unless o.side

  @map_reduce (o)->


new Mem.Rule("trap").schema ->
  @scope (all)->

  @default ->

  @deploy (o)->

  @map_reduce (o)->


new Mem.Rule("able").schema ->
  @scope (all)->
    by_rolestate: (bits)->
      masks =
        for mask in all.masks when 0 == bits .&. mask
          bits .|.= mask
          mask
      all.where(mask:masks)

  @default ->

  @deploy (o)->
    o.at = switch o.at
         | "main"     => {         +main                       }
         | "start"    => { +start                              }
         | "progress" => { +start, +main                       }
         | "prologue" => {                +prologue            }
         | "around"   => {                +prologue, +epilogue }
         | "all"      => { +start, +main, +prologue, +epilogue }
         | _          => {                                     }

  @map_reduce (o)->


Mem.rule.able.set <%= JSON.generate SET_ABLES %>
for mask, id of SOW_RECORD.maskstates when o = Mem.ables.find(id)
  o.mask = mask
Mem.ables.masks = _.sortBy Object.keys(SOW_RECORD.maskstates), (i)-> -i

Mem.rule.trap.set <%= JSON.generate SET_TRAPS %>
Mem.rule.role.set <%= JSON.generate SET_ROLES %>
