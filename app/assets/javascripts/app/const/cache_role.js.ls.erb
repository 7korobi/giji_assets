new Mem.Rule("role").schema ->
  id_index = SOW_RECORD.roles.concat SOW_RECORD.gifts

  @order "order"

  @scope (all)->
    is: (side)->
      all.where (o)->
        o.side == side && -1 < o.order

    hide: ->
      all.where (o)->
        o.order < 0

  @default ->

  @deploy (o)->
    o.ables ||= []
    o.HELP ||= ""

    o.order = id_index.indexOf o._id

    o.side = o.group.toLowerCase() if o.group? && o.group != "OTHER"
    o.side = "gift"  if ("gift" in o.ables)
    if o.group == "MOB"
      o.side = "mob"
      o.order = 0
    o.side = "other" unless o.side

  @map_reduce (o)->


new Mem.Rule("trap").schema ->
  @scope (all)->

  @default ->

  @deploy (o)->

  @map_reduce (o)->


new Mem.Rule("able").schema ->
  @scope (all)->
    by_rolestate: (bits)->
      q = all.where(->)
      q._hash = hash = {}
      q._list = list = []
      if bits?
        for mask in all.masks
          if 0 == (bits .&. mask)
            id = SOW_RECORD.maskstates[mask]
            o = all.find(id)
            if o
              hash[id] = o
              list.push o
            bits .|.= mask
      q

  @default ->

  @deploy (o)->
    o.at = switch o.at
         | "main"     => {         +main }
         | "start"    => { +start        }
         | "progress" => { +start, +main }
         | _          => {               }

  @map_reduce (o)->


Mem.rule.able.set <%= JSON.generate SET_ABLES %>
Mem.ables.masks = _.sortBy Object.keys(SOW_RECORD.maskstates), (i)-> -i

Mem.rule.trap.set <%= JSON.generate SET_TRAPS %>
Mem.rule.role.set <%= JSON.generate SET_ROLES %>
